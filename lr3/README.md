# Лабораторная работа №3  
Построение портрета и сборка конечноэлементной матрицы  
(лагранжевы базисные функции первого порядка)

## Цель работы

Реализовать алгоритм построения портрета и сборки конечноэлементной матрицы для разреженного строчного формата хранения.
Протестировать написанную программу.

## Используемые файлы

- `build_portrait.py` — основной решатель c несколькими тестами.
- `solution_*.txt` — численное решение и ошибки для каждого теста.
- `portrait_*.txt` — портрет матрицы для каждого теста.

## Построение портрета матрицы

### Структура портрета

Используется разреженный формат:

- `ig` — массив размеров `N+1`, где `ig[i]..ig[i+1]-1` — диапазон индексов в `jg`, соответствующий строке/узлу `i`;
- `jg` — массив номеров столбцов верхней треугольной части матрицы.

Диагональ хранится отдельно в массиве `di`.

### Алгоритм `build_portrait`

```python
def build_portrait(n_nodes: int, elements):
    row_to_cols = defaultdict(set)

    for elem_nodes, _mat in elements:
        k = len(elem_nodes)
        for a in range(k):
            ia = elem_nodes[a]
            for b in range(a + 1, k):
                ib = elem_nodes[b]
                if ia == ib:
                    continue
                i_min = min(ia, ib)
                i_max = max(ia, ib)
                row_to_cols[i_min].add(i_max)

    ig = [0] * (n_nodes + 1)
    jg: List[int] = []

    nnz = 0
    for i in range(n_nodes):
        cols = row_to_cols.get(i, set())
        cols_sorted = sorted(cols)
        nnz += len(cols_sorted)
        ig[i + 1] = nnz
        jg.extend(cols_sorted)

    return ig, jg
```

Логика:

- для каждого элемента перебираются все пары его узлов `(ia, ib)`;
- храним только пары c `i_min < i_max` (верхний треугольник);
- для каждой строки `i_min` накапливаем множество столбцов `i_max`;
- из множеств формируем отсортированные списки столбцов и строим массивы `ig`, `jg`.
---

## Разреженный формат глобальной матрицы

Инициализация:

```python
def init_global_matrix(ig, jg):
    n = len(ig) - 1
    nnz = len(jg)
    di  = [0.0] * n        # диагональ
    ggl = [0.0] * nnz      # нижний треугольник
    ggu = [0.0] * nnz      # верхний треугольник
    b   = [0.0] * n        # правая часть
    return di, ggl, ggu, b
```

Портрет сохраняется функцией `save_portrait("portrait_*.txt", ig, jg)`.

---

## Локальные матрицы и правая часть

### Локальная матрица жёсткости

Цель — для каждого четырёхугольного элемента построить матрицу

$$
K_{ij} = \int_{Q_e} \lambda \, (\nabla N_i, \nabla N_j)\,dx\,dy,
$$

где $N_i$ — билинейные лагранжевы базисные функции первого порядка на этом элементе.

В функции `compute_local_stiffness_quad` это делается так.

1. **Упорядочивание вершин и переход к эталонному квадрату.**  
   По координатам вершин элемента выбираются четыре «угла»:

   - нижний‑левый (bl),
   - нижний‑правый (br),
   - верхний‑правый (tr),
   - верхний‑левый (tl).

   Они формируют список `pts_std = [bl, br, tr, tl]` и массивы `x_std`, `y_std`.  
   В таком порядке к ним можно применять стандартные билинейные базисные функции,
   заданные на эталонном квадрате $(\xi,\eta)\in[-1,1]^2$.

2. **Билинейные базисные функции на эталонном квадрате.**
   
$$
N_1(\xi,\eta)=\tfrac14(1-\xi)(1-\eta), \quad
N_2(\xi,\eta)=\tfrac14(1+\xi)(1-\eta),\quad
N_3(\xi,\eta)=\tfrac14(1+\xi)(1+\eta),\quad
N_4(\xi,\eta)=\tfrac14(1-\xi)(1+\eta).
$$

4. **Якобиан отображения $(\xi,\eta) \to (x,y)$.**  
  Четырёхугольник получается из эталонного билинейным отображением

$$
x(\xi,\eta) = \sum_{i=1}^4 N_i(\xi,\eta)\,x_i, \qquad
y(\xi,\eta) = \sum_{i=1}^4 N_i(\xi,\eta)\,y_i,
$$

   где $(x_i,y_i)$ — координаты вершин.

   Производные $\partial x/\partial\xi$, $\partial x/\partial\eta$,
   $\partial y/\partial\xi$, $\partial y/\partial\eta$ собираются
   в матрицу Якобиана
   
$$
J =
\begin{pmatrix}
\dfrac{\partial x}{\partial \xi} & \dfrac{\partial x}{\partial \eta}\\
\dfrac{\partial y}{\partial \xi} & \dfrac{\partial y}{\partial \eta}
\end{pmatrix}.
$$

$$
\det J = J_{11}J_{22} - J_{12}J_{21}.
$$

5. **Переход к производным по $x,y$.**  

$$
\begin{pmatrix}
\dfrac{\partial N_i}{\partial x}
\dfrac{\partial N_i}{\partial y}
\end{pmatrix}
\=
J^{-1}
\begin{pmatrix}
\dfrac{\partial N_i}{\partial \xi}
\dfrac{\partial N_i}{\partial \eta}
\end{pmatrix}.
$$

6. **Интегрирование по элементу (квадратура Гаусса).**  
   Интеграл по физическому элементу заменяется интегралом по эталонному квадрату:

$$
K_{ij} = \int_{Q_e} \lambda(\nabla N_i,\nabla N_j)\,dx\,dy
      = \int_{-1}^1\!\int_{-1}^1
        \lambda(\nabla N_i,\nabla N_j)\,\det J(\xi,\eta)\,d\xi\,d\eta.
$$

   В программе он приближается 4‑точечной квадратурой Гаусса $2\times2$ —
   используются четыре узла $(\xi_k,\eta_k)$ и веса $w_k$:

$$
K_{ij} \approx \sum_{k=1}^4
\lambda\,(\nabla N_i,\nabla N_j)(\xi_k,\eta_k)\,
\det J(\xi_k,\eta_k)\,w_k.
$$

7. **Возврат к исходному порядку узлов.**  
   Матрица $K_\text{std}$ сначала собирается в порядке вершин `bl, br, tr, tl`.  
   Затем она переставляется в порядок `elem_nodes`, с которым дальше
   выполняется сборка глобальной матрицы.

---

### Локальная матрица массы

Локальная матрица массы задаётся формулой

$$
M_{ij} = \int_{Q_e} N_i(x,y)\,N_j(x,y)\,dx\,dy.
$$

Функция `compute_local_mass_quad` использует ту же геометрию и те же
узлы квадратуры, но вместо градиентов берёт значения базисных функций:

- в каждой точке Гаусса вычисляются $N_i(\xi,\eta)$;
- строится тот же Якобиан и его детерминант $\det J$;
- вклад в матрицу аппроксимируется как

$$
M_{ij} \approx \sum_{k=1}^4
N_i(\xi_k,\eta_k)\,N_j(\xi_k,\eta_k)\,
\det J(\xi_k,\eta_k)\,w_k.
$$

После этого матрица, как и для жёсткости, переставляется из стандартного
порядка вершин в порядок `elem_nodes` и возвращается как `M_elem`.

---

### Локальный вектор правой части

Для правой части используется формула

$$
b_i^{(e)} = \int_{Q_e} f(x,y)\,N_i(x,y)\,dx\,dy,
$$

где $f(x,y)$ — заданная функция правой части (см. тесты `lin_y`, `poly`, `exp`).

В `compute_local_rhs_quad`:

- в узлах квадратуры считаются значения базисных функций $N_i(\xi,\eta)$;
- по формуле билинейного отображения восстанавливаются реальные
  координаты точки интегрирования $(x_k,y_k)$;
- по этим координатам вычисляется $f(x_k,y_k)$;
- строится Якобиан и $\det J$;
- локальный вектор накапливается по формуле

$$
  b_i^{(e)} \approx \sum_{k=1}^4
  f(x_k,y_k)\,N_i(\xi_k,\eta_k)\,
  \det J(\xi_k,\eta_k)\,w_k.
$$

Затем компоненты локального вектора приводятся к порядку узлов
`elem_nodes` и добавляются в глобальный вектор правой части $b$.

## Учёт граничных условий

Реализованы две функции:

```python
def build_masks_lin_y(nodes_coords, radius=1.0, eps_axis=1e-8, eps_r=1e-6):
    # дуга r=1 -> Dirichlet
    # оси Ox и Oy -> Neumann

def build_masks_dirichlet_all(nodes_coords, ...):
    # дуга + оси -> Dirichlet на всей границе
```

Они возвращают два логических массива длины `N`:

- `mask_D[i]` — узел `i` принадлежит границе Дирихле;
- `mask_N[i]` — узел `i` принадлежит границе Неймана.

### Поток Неймана по рёбрам

Функция:

```python
def add_neumann_edges(b, elements, nodes_coords, mask_neumann, g_on_edge, eps_axis=1e-8):
    ...
```

Для каждого элемента перебирает его 4 ребра, и если оба конца помечены как Neumann‑узлы, интегрирует вдоль этого отрезка значение граничного потока `g_on_edge(x1,y1,x2,y2)` с помощью одномерной квадратуры Гаусса по отрезку. 
Результат добавляется к соответствующим компонентам глобального вектора `b`.

### Модификация строк Дирихле

```python
def apply_dirichlet(di, ggl, ggu, ig, jg, b,
                    nodes_coords,
                    mask_dirichlet,
                    u_exact):
    for i in range(n):
        if not mask_dirichlet[i]:
            continue
        x, y = nodes_coords[i]
        u_val = u_exact(x, y)
        # обнуляем строку и столбец i
        ...
        di[i] = 1.0
        b[i]  = u_val
```

То есть:

- на диагонали ставится 1,
- все внедиагональные элементы в строке и столбце обнуляются,
- правая часть заменяется на точное значение граничного решения.

---
