# Лабораторная работа №4  
**Методы построения изображений конечноэлементных решений**

## Цель работы

Изучить методы построения изображений конечноэлементного решения при решении различных задач.  
Реализовать методы построения изображения решения для элементов высоких порядков.

---

## Постановка задачи

Для уже построенной двумерной конечноэлементной сетки (файлы `computational_domain.txt` → `radial_mesh.txt`) и численного решения задачи (файл `solution_*.txt`):

1. Сгенерировать треугольную сетку по исходной четырёхугольной:
   - выполнить измельчение четырёхугольных элементов;
   - каждый четырёхугольник разбить на два треугольника.

2. Реализовать программу построения изображения функции:
   - заливка цветом по значению решения;
   - вывод изолиний.

3. Использовать полученную программу для визуализации решения, вычисленного в ЛР3, на построенной в ЛР1–ЛР2 сетке.
---

## Основные функции `plot_solution.py`

### Чтение сетки

```python
def read_mesh(filename: str) -> Tuple[List[Tuple[float, float]], List[List[int]]]:
    ...
```

- Читает `radial_mesh.txt`.
- Возвращает:
  - `nodes` – список координат узлов `[(x0, y0), ..., (xN-1, yN-1)]`;
  - `quads` – список четырёхугольных элементов `[[n1, n2, n3, n4], ...]`

### Чтение решения

```python
def read_solution_table(filename: str) -> Dict[int, float]:
    ...
```

- Читает таблицу `solution_poly.txt`.
- Возвращает словарь `sol[i_node] = u_num`.

## Билинейная интерполяция на четырёхугольнике

Для измельчения четырёхугольных элементов и вычисления значений решения в новых узлах используется **билинейная интерполяция**.

Рассматривается эталонный квадрат в локальных координатах
$$(s,t) \in [0,1]\times[0,1]$$
с вершинами:

- $(0,0)$ – значение $u_{00}$,
- $(1,0)$ – значение $u_{10}$,
- $(1,1)$ – значение $u_{11}$,
- $(0,1)$ – значение $u_{01}$.

Тогда билинейная интерполяция задаётся формулой

$$
u(s,t) = u_{00}(1-s)(1-t) + u_{10}s(1-t) + u_{11}s t + u_{01}(1-s)t.
$$

Эта формула используется так:

1. Для каждого нового узла внутри исходного четырёхугольника задаются локальные координаты $(s,t)$ (например, $s = i/n_x$, $t = j/n_y$ для равномерного разбиения по $n_x \times n_y$).
2. Значения решения в вершинах элемента берутся из узлов исходной сетки (`u_coarse`).
3. По формуле выше вычисляется значение решения в новом узле.
---

## Измельчение четырёхугольников и построение треугольной сетки

### Разбиение четырёхугольников на треугольники

```python
def quads_to_tris(elements: List[List[int]]) -> List[Tuple[int, int, int]]:
    ...
```

- Каждый четырёхугольник `[n1, n2, n3, n4]` разбивается на два треугольника:
  - `(n1, n2, n3)`,
  - `(n1, n3, n4)`.

### Локальное измельчение четырёхугольников

```python
def refine_quads_with_u(
    nodes: List[Tuple[float, float]],
    quads: List[List[int]],
    u_coarse: np.ndarray,
    nx: int = 2,
    ny: int = 2,
) -> Tuple[List[Tuple[float, float]], np.ndarray, List[List[int]]]:
    ...
```

- Для каждого исходного четырёхугольника строится равномерная сетка
  из `nx × ny` меньших четырёхугольников.
- Координаты узлов и значения решения в новых узлах получаются
  билинейной интерполяцией по вершинам исходного элемента.
- Возвращает:
  - `ref_nodes` – список новых узлов;
  - `u_refined` – значения решения в новых узлах;
  - `ref_quads` – список новых четырёхугольных элементов.

---

## Визуализация решения

В функции `main()`:

1. Читаются файлы:
   ```python
   mesh_file = "radial_mesh.txt"
   solution_file = "solution_*.txt"
   ```

2. Формируется вектор значений на исходной сетке:
   ```python
   u_coarse = build_u_on_coarse(nodes, sol)
   ```

3. Выполняется измельчение четырёхугольников:
   ```python
   nx_ref, ny_ref = 2, 2
   ref_nodes, u_refined, ref_quads = refine_quads_with_u(
       nodes, quads, u_coarse, nx=nx_ref, ny=ny_ref
   )
   ```

4. Новые четырёхугольники переводятся в треугольники:
   ```python
   tris = quads_to_tris(ref_quads)
   ```

5. Создаётся `Triangulation` из библиотеки `matplotlib.tri`:
   ```python
   triang = mtri.Triangulation(x, y, triangles)
   ```

6. Строится изображение поля:
   - цветовая заливка:
     ```python
     tpc = ax.tripcolor(triang, u_refined, shading="gouraud", cmap="viridis")
     fig.colorbar(tpc, ax=ax)
     ```
   - изолинии:
     ```python
     levels = np.linspace(u_refined.min(), u_refined.max(), n_levels)
     ax.tricontour(triang, u_refined, levels=levels, colors="k", linewidths=0.5)
     ```
   - контур сетки:
     ```python
     ax.triplot(triang, color="black", linewidth=0.2, alpha=0.5)
     ```
